<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
    <title>Osmosis - Taiiwo</title>
	<div id="scaling"></div>
	<script type="text/javascript" src="js/phaser.min.js"></script>
    <style type="text/css">
			@font-face{font-family:"Pixels";src:url('font.ttf');}
      body {
          margin: 0;
      }
    </style>
</head>
<body style="height: 100%;">

<script type="text/javascript">
var game = new Phaser.Game('100', '100', Phaser.AUTO, 'scaling', { preload: preload, create: create, update: update });

var numImages = 6;
function preload() {
	for (var i = 0; i < numImages; i++){
		game.load.image('youWin'+ i.toString(), 'assets/youWin'+ i.toString() +'.png');
	}
}
var balls;
var barriers;
var backgrounds;
var inPlay = false;
var started = false;
var d = new Date();
var startTime = 0;
var numberOfBalls = 2;
var ballSpeed = 200;
var red 		= {ball: '#d23d3d', background: '#e84f4f'};
var green 	= {ball: '#a0cf5d', background: '#b8d68c'};
var yellow	= {ball: '#f39d21', background: '#e1aa5d'};
var blue		= {ball: '#4e9fb1', background: '#7dc1cf'};
var purple 	= {ball: '#8542ff', background: '#9b64fb'};
var coast	 	= {ball: '#42717b', background: '#6d878d'};
var worldColours = [];
var colours = [red, yellow, coast, blue, purple, green];
var scores;
var startButton;
var last2 = [3, 5];
function create() {

	//  We're going to be using physics, so enable the Arcade Physics system
	game.physics.startSystem(Phaser.Physics.ARCADE);

	var colour1 = colours[randInt(0, colours.length - 1)];
	while (1){
		var colour2 = colours[randInt(0,colours.length - 1)];
		if (colour2 != colour1){
			break;
		}
	}
	worldColours = [colour1, colour2];

	//make backgrounds
	backgrounds = game.add.group();
	makeBackgrounds();

	//make barrier group
	barriers = game.add.group();

	//variables that are true for both barriers
	var barrierWidth = 10;
	var barrierHeight = game.world.height * 0.9;
	var barrierGap = game.world.height * 0.1;
	//variables that are different from barrier to barrier
	//these basically set their positions relative the the center of the barrier gap
	var barrierPositionYOffsets = [-barrierHeight - barrierGap, barrierGap];

	//set up each barrier so that they have the correct properties each
	for (var i = 0; i < barrierPositionYOffsets.length; i++){
		//this is the only property that changes
		var barrierPositionYOffset = barrierPositionYOffsets[i];
		//create the barrier object
		var barrier = game.add.bitmapData(barrierWidth, barrierHeight);
		//draw a rectangle
		barrier.ctx.beginPath();
		barrier.ctx.rect(0, 0, barrierWidth, barrierHeight);
		barrier.ctx.fillStyle = 'white';
		barrier.ctx.fill();
		//register our barrier as a sprite and place it in the world
		var barrierSprite = game.add.sprite(game.world.centerX - barrierWidth / 2,
			game.world.centerY + barrierPositionYOffset,
			barrier
		);
		//assign the positions offset as a property so we know which one to use without
		//having to identify it
		barrierSprite.positionYOffset = barrierPositionYOffset;
		barriers.add(barrierSprite);
	}
	game.physics.enable(barriers);
	barriers.setAllChildren('body.immovable', true);
	barriers.setAllChildren('inputEnabled', true);

	var style = {
		font: "35px Pixels",
		fill: "#fff",
		align: "center"
	};
  startButton = game.add.text(0, 0, "Click to Start", style);
	startButton.x = game.world.centerX - startButton.width / 2;
	startButton.y = game.world.centerY - startButton.height / 2;
	game.input.onDown.addOnce(function (){
		//start game
		if (inPlay == false) {
			startTime = d.getTime()
			started = true;
			startButton.kill();
			inPlay = true;
			//make balls
			balls = game.add.group();
			makeBalls(numberOfBalls / 2, worldColours[0], balls);
			makeBalls(numberOfBalls / 2, worldColours[1], balls);
		}
	}, this);
	scores = game.add.group();
	setInterval(makeScores, 1000);
}
function makeScores(){
	if (inPlay == true){
		scores.removeAll()
		d = new Date();
		var time = d.getTime() - startTime;
		time = Math.round(time / 1000);
		var text = "Time: "+ time +"s  Balls: "+ numberOfBalls +"  Speed: " + Math.floor(ballSpeed);
		var style = {
			font: "25px Pixels",
			fill: "#fff",
			align: "left"
		};
  	var text = game.add.text(10, 10, text, style);
		scores.add(text);
	}
}
function update(){
	if (started){
		game.physics.arcade.collide(balls, barriers);
		for (var i = 0; i < barriers.children.length; i++){
			var barrier = barriers.children[i];
			game.physics.arcade.moveToXY(
				barrier,
				game.world.centerX - barrier.width / 2,
				game.input.activePointer.y + barrier.positionYOffset,
				undefined,
				100
			);
			if (barrier.y + barrier.positionYOffset == game.input.activePointer.y ){
				barrier.body.velocity.y = 0;
			}
		}
		var ballsInWrongPlace = 0;
		for (var i = 0; i < balls.children.length; i++){
			var ball = balls.children[i];
			if (Math.abs(ball.body.velocity.x) < ball.speed * 0.25){
				//if a ball is not traveling at least 45 degrees in the x direction
				ball.body.velocity.x = ball.speed * 0.25;
			}
			if (Math.abs(ball.body.velocity.x) + Math.abs(ball.body.velocity.y) != ball.speed) {
				var currentSpeed = Math.abs(ball.body.velocity.x) + Math.abs(ball.body.velocity.y);
				var correctionRatio = ball.speed / currentSpeed;
				ball.body.velocity.x *= correctionRatio;
				ball.body.velocity.y *= correctionRatio;
			}
			if (ball.x < game.world.centerX && ball.colour != worldColours[0]){
				ballsInWrongPlace++;
			}
			if (ball.x > game.world.centerX && ball.colour != worldColours[1]){
				ballsInWrongPlace++;
			}
		}
		if (ballsInWrongPlace == 0 && inPlay){
			youWin();
			inPlay = false;
		}
		if (inPlay == false){
			startButton.y = barriers.children[1].y - barriers.children[1].positionYOffset - startButton.height / 2;
		}
	}
}
function makeBackgrounds(){
	//make 2 background images
	for (var i = 0; i < worldColours.length; i++){
		var background = game.add.bitmapData(game.world.centerX, game.world.height);
		background.ctx.beginPath();
		background.ctx.rect(0, 0, game.world.centerX, game.world.height);
		background.ctx.fillStyle = worldColours[i]['background'];
		background.ctx.fill();
		var backgroundSprite = game.add.sprite(game.world.centerX * i, 0, background);
		backgrounds.add(backgroundSprite);
		backgroundSprite.sendToBack();
	}
}
function createBall(radius, colour, group){
	// create a new bitmap data object
	var ball = game.add.bitmapData(radius*2, radius*2);

	// draw to the canvas context like normal
	ball.ctx.beginPath();
	ball.ctx.arc(radius, radius, radius, 0, 2 * Math.PI, false);
	ball.ctx.fillStyle = colour['ball'];
	ball.ctx.fill();
	/*
	ball.ctx.lineWidth = radius * 0.05;
  ball.ctx.strokeStyle = colour['ballStroke'];
  ball.ctx.stroke();
	*/
	// use the bitmap data as the texture for the sprite
	var sprite = game.add.sprite(randInt(0,game.world.width - 20), randInt(0,game.world.height - 20), ball);
	sprite.speed = ballSpeed;
	sprite.colour = colour;
	group.add(sprite);
	game.physics.enable(sprite, Phaser.Physics.ARCADE);
	var rand = randInt(1, sprite.speed - 1);
	if (randInt(0,1) == 1){
		sprite.body.velocity.x = rand;
	}
	else {
		sprite.body.velocity.x = -rand;
	}
	if (randInt(0,1) == 1){
		sprite.body.velocity.y = sprite.speed - rand;
	}
	else {
		sprite.body.velocity.y = -(sprite.speed - rand);
	}
	group.add(sprite);
	game.physics.enable(sprite);
	sprite.body.bounce.set(1);
	sprite.body.collideWorldBounds = true;
	//sprite.body.maxAngular = Math.sqrt(sprite.speed);

}
function makeBalls(amount, colour, group){
	for (var i = 0; i < amount; i++){
		createBall(10, colour, group)
	}
}
function randInt(min,max){
    return Math.floor(Math.random()*(max-min+1)+min);
}
function youWin(){
	balls.removeAll();
	youWinSprite = game.add.sprite(0, 0, 'youWin' + randInt(0,numImages - 1));
	youWinSprite.x = (game.world.width / 2) - (youWinSprite.width / 2);
	youWinSprite.y = 50;
	inPlay = false;
	var style = {
		font: "35px Pixels",
		fill: "#fff",
		align: "center"
	};
  startButton = game.add.text(0, 0, "Click to Level Up!", style);
	startButton.x = game.world.centerX - startButton.width / 2;
	startButton.y = game.world.height - 10 - startButton.height;
	youWinSprite.bringToTop();
	game.input.onDown.addOnce(function (){
		//start game
		if (inPlay == false) {
			startButton.kill();
			youWinSprite.kill();
			inPlay = true;
			d = new Date();
			startTime = d.getTime();
			var colour1 = colours[randInt(0, colours.length - 1)];
			while (1){
				var colour2 = colours[randInt(0,colours.length - 1)];
				if (colour2 != colour1){
					break;
				}
			}
			numberOfBalls = nextFib();
			ballSpeed = ballSpeed * (1 + (Math.PI / 10));
			worldColours = [colour1, colour2];
			makeBalls(numberOfBalls / 2, worldColours[0], balls);
			makeBalls(numberOfBalls / 2, worldColours[1], balls);
			backgrounds.children[0].kill();
			backgrounds.children[1].kill();
			makeBackgrounds();
		}
	}, this);
}
function nextFib(){
	var ret = last2[0] + last2[1];
	last2[0] = last2[1];
	last2[1] = ret;
	return ret;
}

</script>

</body>
</html>
